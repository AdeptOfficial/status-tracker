{% extends "base.html" %}

{% block title %}Active Requests - Status Tracker{% endblock %}

{% block content %}
<div class="space-y-6">
    <!-- Connection status indicator (fixed, not refreshed) -->
    <div class="flex justify-end">
        <div class="flex items-center space-x-2">
            <span class="text-sm text-gray-400" id="update-status">Connecting...</span>
            <div id="connection-dot" class="w-2 h-2 bg-yellow-500 rounded-full"></div>
        </div>
    </div>

    <!-- Refreshable content area (includes header + cards) -->
    <div id="request-list"
         hx-get="/"
         hx-trigger="status-update"
         hx-select="#request-list"
         hx-swap="outerHTML">

        <!-- Header with stats -->
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 border-b border-gray-700 pb-4 mb-4">
            <div>
                <h1 class="text-2xl font-bold">Active Requests</h1>
                <p class="text-gray-400">{{ requests|length }} request{% if requests|length != 1 %}s{% endif %} in progress</p>
            </div>
        </div>

        <!-- Request cards grid -->
        <div class="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {% if requests %}
            {% for request in requests %}
                {% include "components/card.html" %}
            {% endfor %}
        {% else %}
            <div class="col-span-full text-center py-12">
                <svg class="mx-auto h-12 w-12 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                <h3 class="mt-2 text-lg font-medium text-gray-300">No active requests</h3>
                <p class="mt-1 text-gray-500">Ready for requests.</p>
            </div>
        {% endif %}
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // SSE connection for real-time updates
    // Why SSE? It's simpler than WebSocket for one-way serverâ†’client updates,
    // has native browser auto-reconnect, and is perfect for status dashboards.

    let eventSource = null;
    let reconnectAttempts = 0;
    let isConnecting = false;
    let reconnectTimer = null;
    const maxReconnectAttempts = 10;
    const baseReconnectDelay = 2000;

    function updateConnectionStatus(connected, message) {
        const dot = document.getElementById('connection-dot');
        const status = document.getElementById('update-status');
        if (!dot || !status) return;

        if (connected) {
            dot.className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse';
            status.textContent = message || 'Live updates active';
            status.className = 'text-sm text-green-400';
        } else {
            dot.className = 'w-2 h-2 bg-red-500 rounded-full';
            status.textContent = message || 'Disconnected';
            status.className = 'text-sm text-red-400';
        }
    }

    function connectSSE() {
        // Prevent multiple simultaneous connection attempts
        if (isConnecting) {
            console.log('SSE connection already in progress, skipping');
            return;
        }

        // Clear any pending reconnect
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
        }

        // Close existing connection if any
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }

        isConnecting = true;
        updateConnectionStatus(false, 'Connecting...');

        try {
            eventSource = new EventSource('/api/sse');
        } catch (err) {
            console.error('Failed to create EventSource:', err);
            isConnecting = false;
            scheduleReconnect();
            return;
        }

        eventSource.onopen = function() {
            console.log('SSE connection opened');
            isConnecting = false;
            reconnectAttempts = 0;
        };

        // Handle the initial connected event
        eventSource.addEventListener('connected', function(e) {
            console.log('SSE connected event received');
            updateConnectionStatus(true, 'Live updates active');
        });

        // Handle update events (state changes, progress updates)
        eventSource.addEventListener('update', function(e) {
            console.log('SSE update received:', e.data);

            // Parse the update to show what changed
            try {
                const data = JSON.parse(e.data);
                const title = data.request?.title || 'Request';

                // Brief visual feedback
                updateConnectionStatus(true, `Updated: ${title}`);

                // Reset status text after 2 seconds
                setTimeout(() => {
                    updateConnectionStatus(true, 'Live updates active');
                }, 2000);
            } catch (err) {
                console.error('Failed to parse SSE data:', err);
            }

            // Trigger htmx to refresh the list
            htmx.trigger('#request-list', 'status-update');
        });

        eventSource.onerror = function(e) {
            console.error('SSE error:', e);
            isConnecting = false;

            // Check if connection was closed cleanly
            if (eventSource.readyState === EventSource.CLOSED) {
                updateConnectionStatus(false, 'Connection closed');
                scheduleReconnect();
            } else {
                updateConnectionStatus(false, 'Connection error');
                eventSource.close();
                scheduleReconnect();
            }
        };
    }

    function scheduleReconnect() {
        if (reconnectTimer) return; // Already scheduled

        if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            // Exponential backoff with jitter
            const delay = Math.min(baseReconnectDelay * Math.pow(1.5, reconnectAttempts - 1), 30000);
            const jitter = Math.random() * 1000;
            const totalDelay = delay + jitter;

            updateConnectionStatus(false, `Reconnecting in ${Math.round(totalDelay/1000)}s...`);
            console.log(`SSE reconnect scheduled in ${totalDelay}ms (attempt ${reconnectAttempts})`);

            reconnectTimer = setTimeout(() => {
                reconnectTimer = null;
                connectSSE();
            }, totalDelay);
        } else {
            updateConnectionStatus(false, 'Connection failed - refresh page');
        }
    }

    // Connect on page load
    connectSSE();

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
        }
        if (eventSource) {
            eventSource.close();
        }
    });
</script>
{% endblock %}
